# AUTOGENERATED! DO NOT EDIT! File to edit: 00_core.ipynb (unless otherwise specified).

__all__ = ['DotPathDict', 'FhirClient', 'request_to_cache_file', 'CachedResponse', 'requests_get', 'get_as_raw_json',
           'get_next_as_raw_json', 'get_all_entries', 'get_all_resources', 'get_by_reference']

# Cell
import requests, json, datetime, collections, typing, urllib
from pathlib import Path
from fastcore.basics import patch_to

# Cell
class DotPathDict(collections.UserDict):
    "Wraps a `dict` to allow simple dot notation search of nested `dict`s"

    def __getitem__(self, dot_paths):
        "Allows dot search via subscript"
        for dot_path in dot_paths.split(' OR '):
            data, found, path_parts = self.data, True, []
            for path_part in dot_path.split('.'):
                if not isinstance(data, (dict, DotPathDict)):
                    path_parts = '.'.join(path_parts)
                    raise Exception(f'Expected "{path_parts}" to be a `dict` but found {type(data)} {data}')
                path_parts.append(path_part)
                if not path_part in data:
                    found = False
                    break # try the next dot_path, if we have one
                data = data[path_part]
                if isinstance(data, list) and data:
                    data = data[0] # TODO: is it OK to just pull the 1st item from the list?
            if found:
                return DotPathDict(data) if isinstance(data, dict) else data

# Cell
class FhirClient:
    "Helps to GET FHIR resources"
    def __init__(self, api_base:str, x_api_key:str=None, use_local_cache=True):
        self.api_base = api_base
        self.use_local_cache = use_local_cache
        self.request_headers = {}
        if x_api_key is not None:
            self.request_headers['x-api-key'] = x_api_key
        self.default_params = {}

# Cell
def request_to_cache_file(url, params):
    parsed_url = urllib.parse.urlparse(url)
    cache_folder = Path('data/cache/')/parsed_url.netloc
    cache_index = {}
    if (cache_folder/'index.json').is_file():
        with open(cache_folder/'index.json') as f:
            cache_index = json.load(f)
    cache_key = url if params is None else f'{url}?{urllib.parse.urlencode(params)}'
    if cache_key in cache_index:
        return cache_folder/cache_index[cache_key]
    cache_index[cache_key] = f'''{parsed_url.path.replace('/', '')}-{len(cache_index)}'''
    cache_folder.mkdir(parents=True, exist_ok=True)
    with open(cache_folder/'index.json', 'w') as f:
        json.dump(cache_index, f, indent=2)
    return cache_folder/cache_index[cache_key]

# Cell
class CachedResponse:
    def __init__(self, cache_file):
        self.status_code = 200
        with open(cache_file) as f:
            self.text = f.read()
    def json(self):
        return json.loads(self.text)

# Cell
def requests_get(url, params, headers=None, use_local_cache=True):
    if use_local_cache:
        cache_file = request_to_cache_file(url, params)
        if cache_file.is_file():
            print('GET', cache_file, 'from local cache')
            return CachedResponse(cache_file)
    # HTTP GET from the real FHIR server
    response = requests.get(url, params, headers=headers)
    print('GET', response.url, 'Status', response.status_code)
    # cache the result returned by the real FHIR server
    if use_local_cache and response.status_code == 200:
        cache_file.parent.mkdir(parents=True, exist_ok=True)
        with open(cache_file, 'w') as f:
            f.write(response.text)
    return response

# Cell
@patch_to(FhirClient)
def get_as_raw_json(self, resource_type:str, params:dict=None) -> dict: # TODO: rename to get and wrap results
    "GET FHIR resources of `resource_type` in JSON format"
    url = f'{self.api_base}/{resource_type}'
    params = self.default_params if params is None else params
    return requests_get(url, params, headers=self.request_headers).json()

# @patch_to(FhirClient)
# def get_as_response(self, resource_type:str, params:dict=None) -> requests.Response:
#     "GET FHIR resources of `resource_type` and return python `Reponse`"
#     url = f'{self.api_base}/{resource_type}'
#     params = self.default_params if params is None else params
#     return requests_get(url, params, headers=self.request_headers)

# Cell
@patch_to(FhirClient)
def get_next_as_raw_json(self, json_response:dict) -> dict:
    "GET the next set of results"
    for link in json_response['link']:
        if link['relation'] == 'next':
            url = link['url']
            response = requests_get(url, None, self.request_headers, self.use_local_cache)
            print('GET', url, 'Status', response.status_code)
            return response.json()

@patch_to(FhirClient)
def get_all_entries(self, resource_type:str, params:dict=None, page_limit:int=100) -> typing.List[DotPathDict]:
    "Return a list of entries of `resource_type` in JSON format while taking care of bundle pageing"
    page_count, result = 0, []
    bundle = self.get_as_raw_json(resource_type, params)
    total = bundle.get('total', 'Unknown')
    if total == 0:
        print('Returning', len(result), 'entries')
        return result
    while bundle is not None:
        if bundle.get('resourceType', None) != 'Bundle':
            raise Exception(f'Expected a bundle but found', bundle) # might be {'resourceType': 'OperationOutcome' ...
        result.extend(bundle['entry']) # todo check for OperationOutcome etc in `entry`
        page_count += 1
        if page_count > page_limit:
            print('Stopping early. Will return', len(result), 'entries out of total', total)
            break
        bundle = client.get_next_as_raw_json(bundle)
    def _expected_resource_type(resource):
        actual_resource_type = resource.get('resource', {}).get('resourceType', None)
        if actual_resource_type != resource_type:
            print('Removing resource. Expected', resource_type, 'but found', actual_resource_type)
            return False
        return True
    result = [r for r in result if _expected_resource_type(r)]
    result = [DotPathDict(r) for r in result]
    print('Returning', len(result), 'entries')
    return result

@patch_to(FhirClient)
def get_all_resources(self, resource_type:str, params:dict=None, page_limit:int=100):
    "Return a list of resources of `resource_type` in JSON format"
    result = self.get_all_entries(resource_type, params, page_limit)
    result = [r['resource'] for r in result]
    return result

@patch_to(FhirClient)
def get_by_reference(self, reference:str):
    "Return a resource read from a FHIR server by reference, as a list containg a single bundle entry"
    if reference.startswith(self.api_base):
        reference = reference[len(self.api_base):].strip('/')
    if reference.startswith('http'):
        print(f'WARNING: Found reference {reference} that does not start with {api_base}')
        return []
    resource_type, id = reference.split('/')
    single_resource = self.get_as_raw_json(resource_type, id)
    return [dict(fullUrl = f'{self.api_base}/{resource_type}/{id}', resource = single_resource)]